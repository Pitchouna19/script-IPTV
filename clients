server {
    listen 9090;

    # Lire et définir le server_name en utilisant Lua
    set_by_lua_block $domain {
        local cjson = require "cjson" -- Charger le module cjson pour lire le JSON
        local file = io.open("/var/www/html/xtream.json", "r") -- Ouvrir le fichier JSON

        if file then
            local content = file:read("*a") -- Lire tout le contenu du fichier
            file:close()

            local json = cjson.decode(content) -- Parser le contenu JSON
            if json and json.domaine then
                -- Supprimer les préfixes http:// et https:// s'ils sont présents
                local domain = json.domaine:gsub("https?://", "")
                return domain -- Retourner le domaine pour server_name
            end
        end

        return "_" -- Retourner une valeur par défaut si le fichier n'est pas lisible ou le domaine absent
    }

    server_name $domain;

    location / {
        root /var/www/html;
        index index.html;
    }

    location /live/404.mp4 {
        alias /var/www/html/src-img/404.mp4;  # Utilisez alias pour spécifier le chemin du fichier
        #internal;  # Pour éviter des accès directs depuis l'extérieur
    }

    location /live/ {
        content_by_lua_block {
        local json = require("cjson")
        
        -- Fonction pour nettoyer les chaînes
        local function trim(s)
            return (s:gsub("^%s*(.-)%s*$", "%1"))
        end

        -- Fonction pour rediriger vers 404.mp4
        local function redirect_to_404()
            local error_url = "http://localhost:9090/live/404.mp4"
            ngx.redirect(error_url)
        end

        -- Charger et vérifier acces.json
        local file = io.open("/var/www/html/acces.json", "r")
        if not file then
            ngx.log(ngx.ERR, "Erreur: Impossible d'ouvrir acces.json")
            return redirect_to_404()
        end

        local data = file:read("*a")
        file:close()

        local ok, users = pcall(json.decode, data)
        if not ok then
            ngx.log(ngx.ERR, "Erreur: Format JSON invalide")
            return redirect_to_404()
        end

        -- Extraire user et pass depuis l'URI
        local user, pass = ngx.var.uri:match("/live/([^/]+)/([^/]+)/")
        if not user or not pass then
            ngx.log(ngx.ERR, "Erreur: Identifiants manquants dans l'URL")
            return redirect_to_404()
        end

        -- Vérification des identifiants
        local function check_credentials(user, pass)
            for _, u in ipairs(users.users) do
                if u.user == user and u.pass == pass then
                    return true
                end
            end
            return false
        end

        if not check_credentials(user, pass) then
            ngx.log(ngx.ERR, "Accès refusé : Identifiants incorrects")
            return redirect_to_404()
        end

        -- Extraire l'ID du stream
        local id_stream = ngx.var.uri:match("/live/[^/]+/[^/]+/(.+)")
        if not id_stream then
            ngx.log(ngx.ERR, "Erreur: ID du stream manquant")
            return redirect_to_404()
        end

        -- INTÉGRATION DE LA LOGIQUE STREAMING --
        -- Charger streaming_run.json
        local streaming_file = io.open("/var/www/html/streaming_run.json", "r")
        if not streaming_file then
            ngx.log(ngx.ERR, "Erreur: Impossible d'ouvrir streaming_run.json")
            return redirect_to_404()
        end

        local streaming_content = streaming_file:read("*all")
        streaming_file:close()

        local streaming_data = json.decode(streaming_content)

        -- Transformer id_stream en pattern Lua
        local pattern = "^" .. id_stream:gsub("_(%d+)_", "_%%d+_") .. "$"

        -- Chercher le meilleur serveur
        local best_server = nil
        local matched_channel = nil
        local min_nbc = math.huge

        for _, server in ipairs(streaming_data) do
            if server.channel:match(pattern) then
                if server.nbc < min_nbc then
                    min_nbc = server.nbc
                    best_server = server.serveur
                    matched_channel = server.channel
                elseif server.nbc == min_nbc then
                    if math.random() < 0.5 then
                        best_server = server.serveur
                        matched_channel = server.channel
                    end
                end
            end
        end

        -- Vérifier si un serveur a été trouvé
        if not best_server or not matched_channel then
            ngx.log(ngx.ERR, "Erreur: Aucun serveur disponible")
            return redirect_to_404()
        end

        -- Générer le token
        local token = ngx.encode_base64(tostring(ngx.now()))

        -- Construire l'URL de redirection
        local target_url = "http://" .. best_server .. "/live/" .. matched_channel .. "?token=" .. token
        ngx.log(ngx.ERR, "Redirection vers: " .. target_url)

        -- Effectuer la redirection
        ngx.redirect(target_url)
        }
    }

    location /clients.json {
        alias /var/www/html/clients.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /monitoring.json {
        alias /var/www/html/monitoring.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /update {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /last-modified {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-xtream {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-info {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-bandwidth {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-kickoff {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /cancel-clients {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /streaming {
        content_by_lua_block {
            local cjson = require "cjson"

            -- Ouvrir et lire le fichier streaming_run.json
            local file = io.open("/var/www/html/streaming_run.json", "r")
            if not file then
                ngx.say("999")  -- Retourner 999 si le fichier ne peut pas être lu
                return
            end

            local content = file:read("*all")
            file:close()
            local data = cjson.decode(content)

            -- Récupérer la valeur du paramètre `name` depuis l'URL
            local channel_name = ngx.var.arg_name
            if not channel_name then
                ngx.say("333")  -- Retourner 333 si le paramètre 'name' est manquant
                return
            end

            -- Transformer channel_name en pattern Lua pour ignorer le chiffre central
            local pattern = "^" .. channel_name:gsub("_(%d+)_", "_%%d+_") .. "$"

            -- Chercher le serveur et le channel correspondant
            local best_server = nil
            local matched_channel = nil
            local min_nbc = math.huge  -- Initialisation à l'infini

            for _, server in ipairs(data) do
                if server.channel:match(pattern) then
                    if server.nbc < min_nbc then
                        min_nbc = server.nbc
                        best_server = server.serveur
                        matched_channel = server.channel  -- Stocker le channel correspondant
                    elseif server.nbc == min_nbc then
                        -- En cas d'égalité, choisir un serveur aléatoirement
                        if math.random() < 0.5 then
                            best_server = server.serveur
                            matched_channel = server.channel
                        end
                    end
                end
            end

            -- Retourner la réponse appropriée
            if best_server and matched_channel then
                ngx.say(best_server .. "|" .. matched_channel)
            else
                ngx.say("666")  -- Retourner 666 si aucun serveur n'est trouvé
            end
        }
    }


}
