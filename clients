server {
    listen 9090;

    # Lire et définir le server_name en utilisant Lua
    set_by_lua_block $domain {
        local cjson = require "cjson" -- Charger le module cjson pour lire le JSON
        local file = io.open("/var/www/html/xtream.json", "r") -- Ouvrir le fichier JSON

        if file then
            local content = file:read("*a") -- Lire tout le contenu du fichier
            file:close()

            local json = cjson.decode(content) -- Parser le contenu JSON
            if json and json.domaine then
                -- Supprimer les préfixes http:// et https:// s'ils sont présents
                local domain = json.domaine:gsub("https?://", "")
                return domain -- Retourner le domaine pour server_name
            end
        end

        return "_" -- Retourner une valeur par défaut si le fichier n'est pas lisible ou le domaine absent
    }

    server_name $domain;

    location / {
        root /var/www/html;
        index index.html;
    }

    location /live/404.mp4 {
        alias /var/www/html/src-img/404.mp4;  # Utilisez alias pour spécifier le chemin du fichier
        #internal;  # Pour éviter des accès directs depuis l'extérieur
    }

    location /live/ {
    content_by_lua_block {
        local json = require("cjson")
        local http = require("resty.http")

        -- Configuration des adresses
        local serveur1 = "localhost:9090"
        -- Mapper les IPs locales vers l'IP publique
        local ip_mapping = {
            ["192.168.1.39"] = "king.admin.root.sx:9090"  -- Remplacez par votre IP/domaine public
        }

        -- Fonction pour nettoyer les chaînes
        local function trim(s)
            return (s:gsub("^%s*(.-)%s*$", "%1"))
        end

        -- Fonction pour traduire l'IP locale en IP publique
        local function translate_ip(local_ip)
            return ip_mapping[local_ip] or local_ip
        end

        -- Fonction pour rediriger vers 404.mp4
        local function redirect_to_404()
            local error_url = "http://" .. serveur1 .. "/live/404.mp4"
            ngx.redirect(error_url)
        end

        -- Charger et lire le fichier acces.json
        local file = io.open("/var/www/html/acces.json", "r")
        if not file then
            ngx.log(ngx.ERR, "Erreur: Impossible d'ouvrir acces.json")
            return redirect_to_404()
        end

        local data = file:read("*a")
        file:close()

        local ok, users = pcall(json.decode, data)
        if not ok then
            ngx.log(ngx.ERR, "Erreur: Format JSON invalide")
            return redirect_to_404()
        end

        -- Extraire user et pass depuis l'URI
        local user, pass = ngx.var.uri:match("/live/([^/]+)/([^/]+)/")
        if not user or not pass then
            ngx.log(ngx.ERR, "Erreur: Identifiants manquants dans l'URL")
            return redirect_to_404()
        end

        -- Vérification des identifiants
        local function check_credentials(user, pass)
            for _, u in ipairs(users.users) do
                if u.user == user and u.pass == pass then
                    return true
                end
            end
            return false
        end

        if not check_credentials(user, pass) then
            ngx.log(ngx.ERR, "Accès refusé : Identifiants incorrects")
            return redirect_to_404()
        end

        -- Extraire l'ID du stream
        local id_stream = ngx.var.uri:match("/live/[^/]+/[^/]+/(.+)")
        if not id_stream then
            ngx.log(ngx.ERR, "Erreur: ID du stream manquant")
            return redirect_to_404()
        end

        -- Créer un client HTTP
        local httpc = http.new()
        httpc:set_timeout(5000)

        -- Configuration de la requête
        local res, err = httpc:request_uri("http://127.0.0.1:9090/streaming", {
            method = "GET",
            headers = {
                ["Host"] = "localhost:9090",
                ["User-Agent"] = "OpenResty/Internal",
                ["Accept"] = "*/*"
            },
            query = {
                name = id_stream
            },
            keepalive_timeout = 60,
            keepalive_pool = 10
        })

        if err then
            ngx.log(ngx.ERR, "Erreur de connexion HTTP: " .. tostring(err))
            return redirect_to_404()
        end

        if not res then
            ngx.log(ngx.ERR, "Pas de réponse du serveur streaming")
            return redirect_to_404()
        end

        -- Log de la réponse
        ngx.log(ngx.ERR, "Statut de la réponse: " .. tostring(res.status))
        ngx.log(ngx.ERR, "Corps de la réponse brut: " .. tostring(res.body))

        if res.status ~= 200 then
            ngx.log(ngx.ERR, "Erreur: Statut HTTP invalide: " .. tostring(res.status))
            return redirect_to_404()
        end

        -- Nettoyer la réponse
        local clean_body = trim(res.body)
        ngx.log(ngx.ERR, "Corps de la réponse nettoyé: " .. clean_body)

        -- Analyse de la réponse nettoyée
        local ip, channel_name = clean_body:match("([^|]+)|([^|]+)")
        if not ip or not channel_name then
            ngx.log(ngx.ERR, "Erreur: Format de réponse invalide: " .. tostring(clean_body))
            return redirect_to_404()
        end

        -- Nettoyer l'IP et le nom du channel
        ip = trim(ip)
        channel_name = trim(channel_name)

        -- Traduire l'IP locale en IP publique
        local public_ip = translate_ip(ip)
        ngx.log(ngx.ERR, "IP traduite: " .. ip .. " -> " .. public_ip)

        -- Générer le token
        local token = ngx.encode_base64(tostring(ngx.now()))

        -- Construire l'URL de redirection
        local target_url = "http://" .. public_ip .. "/live/" .. channel_name .. "?token=" .. token
        ngx.log(ngx.ERR, "Redirection vers: " .. target_url)

        -- Effectuer la redirection
        ngx.redirect(target_url)
    }
}


    location /clients.json {
        alias /var/www/html/clients.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /monitoring.json {
        alias /var/www/html/monitoring.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /update {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /last-modified {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-xtream {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-info {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-bandwidth {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-kickoff {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /cancel-clients {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /streaming {
        content_by_lua_block {
            local cjson = require "cjson"

            -- Ouvrir et lire le fichier streaming_run.json
            local file = io.open("/var/www/html/streaming_run.json", "r")
            if not file then
                ngx.say("999")  -- Retourner 999 si le fichier ne peut pas être lu
                return
            end

            local content = file:read("*all")
            file:close()
            local data = cjson.decode(content)

            -- Récupérer la valeur du paramètre `name` depuis l'URL
            local channel_name = ngx.var.arg_name
            if not channel_name then
                ngx.say("333")  -- Retourner 333 si le paramètre 'name' est manquant
                return
            end

            -- Transformer channel_name en pattern Lua pour ignorer le chiffre central
            local pattern = "^" .. channel_name:gsub("_(%d+)_", "_%%d+_") .. "$"

            -- Chercher le serveur et le channel correspondant
            local best_server = nil
            local matched_channel = nil
            local min_nbc = math.huge  -- Initialisation à l'infini

            for _, server in ipairs(data) do
                if server.channel:match(pattern) then
                    if server.nbc < min_nbc then
                        min_nbc = server.nbc
                        best_server = server.serveur
                        matched_channel = server.channel  -- Stocker le channel correspondant
                    elseif server.nbc == min_nbc then
                        -- En cas d'égalité, choisir un serveur aléatoirement
                        if math.random() < 0.5 then
                            best_server = server.serveur
                            matched_channel = server.channel
                        end
                    end
                end
            end

            -- Retourner la réponse appropriée
            if best_server and matched_channel then
                ngx.say(best_server .. "|" .. matched_channel)
            else
                ngx.say("666")  -- Retourner 666 si aucun serveur n'est trouvé
            end
        }
    }


}
