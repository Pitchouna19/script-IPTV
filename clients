server {
    listen 9090;

    # Lire et définir le server_name en utilisant Lua
    set_by_lua_block $domain {
        local cjson = require "cjson" -- Charger le module cjson pour lire le JSON
        local file = io.open("/var/www/html/xtream.json", "r") -- Ouvrir le fichier JSON

        if file then
            local content = file:read("*a") -- Lire tout le contenu du fichier
            file:close()

            local json = cjson.decode(content) -- Parser le contenu JSON
            if json and json.domaine then
                -- Supprimer les préfixes http:// et https:// s'ils sont présents
                local domain = json.domaine:gsub("https?://", "")
                return domain -- Retourner le domaine pour server_name
            end
        end

        return "_" -- Retourner une valeur par défaut si le fichier n'est pas lisible ou le domaine absent
    }

    server_name $domain;

    location / {
        root /var/www/html;
        index index.html;
    }

    location /clients.json {
        alias /var/www/html/clients.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /monitoring.json {
        alias /var/www/html/monitoring.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /update {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /last-modified {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-xtream {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-info {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-bandwidth {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-kickoff {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /cancel-clients {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /streaming {
        content_by_lua_block {
            local cjson = require "cjson"

            -- Ouvrir et lire le fichier streaming_run.json
            local file = io.open("/var/www/html/streaming_run.json", "r")
            if not file then
                ngx.say("999")  -- Retourner 999 si le fichier ne peut pas être lu
                return
            end

            local content = file:read("*all")
            file:close()
            local data = cjson.decode(content)

            -- Récupérer la valeur du paramètre `name` depuis l'URL
            local channel_name = ngx.var.arg_name
            if not channel_name then
                ngx.say("333")  -- Retourner 333 si le paramètre 'name' est manquant
                return
            end

            -- Transformer channel_name en pattern Lua pour ignorer le chiffre central
            local pattern = "^" .. channel_name:gsub("_(%d+)_", "_%%d+_") .. "$"

            -- Chercher le serveur et le channel correspondant
            local best_server = nil
            local matched_channel = nil
            local min_nbc = math.huge  -- Initialisation à l'infini

            for _, server in ipairs(data) do
                if server.channel:match(pattern) then
                    if server.nbc < min_nbc then
                        min_nbc = server.nbc
                        best_server = server.serveur
                        matched_channel = server.channel  -- Stocker le channel correspondant
                    elseif server.nbc == min_nbc then
                        -- En cas d'égalité, choisir un serveur aléatoirement
                        if math.random() < 0.5 then
                            best_server = server.serveur
                            matched_channel = server.channel
                        end
                    end
                end
            end

            -- Retourner la réponse appropriée
            if best_server and matched_channel then
                ngx.say(best_server .. "|" .. matched_channel)
            else
                ngx.say("666")  -- Retourner 666 si aucun serveur n'est trouvé
            end
        }
    }


}
