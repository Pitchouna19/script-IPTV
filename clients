server {
    listen 9090;

    # Lire et définir le server_name en utilisant Lua
    set_by_lua_block $domain {
        local cjson = require "cjson" -- Charger le module cjson pour lire le JSON
        local file = io.open("/var/www/html/xtream.json", "r") -- Ouvrir le fichier JSON

        if file then
            local content = file:read("*a") -- Lire tout le contenu du fichier
            file:close()

            local json = cjson.decode(content) -- Parser le contenu JSON
            if json and json.domaine then
                -- Supprimer les préfixes http:// et https:// s'ils sont présents
                local domain = json.domaine:gsub("https?://", "")
                return domain -- Retourner le domaine pour server_name
            end
        end

        return "_" -- Retourner une valeur par défaut si le fichier n'est pas lisible ou le domaine absent
    }

    server_name $domain;

    location / {
        root /var/www/html;
        index index.html;
    }

    location /live/404.mp4 {
        root /var/www/html/src-img/404.mp4;  # Remplacez par le chemin où se trouve 404.mp4
        #internal;  # Pour éviter des accès directs depuis l'extérieur
    }

    location /live/ {
        content_by_lua_block {
        local json = require("cjson")
        local http = require("resty.http")

        -- Définir l'adresse du serveur1
        local serveur1 = "localhost:9090"  -- Remplacez par l'adresse réelle de votre serveur

        -- Fonction pour rediriger vers 404.mp4
        local function redirect_to_404()
            local error_url = "http://" .. serveur1 .. "/live/404.mp4"
            ngx.redirect(error_url)
        end

        -- Charger et lire le fichier acces.json
        local file = io.open("/var/www/html/acces.json", "r")  -- Chemin corrigé
        if not file then
            ngx.log(ngx.ERR, "Erreur: Impossible d'ouvrir acces.json")
            return redirect_to_404()  -- Redirection si le fichier est introuvable
        end

        local data = file:read("*a")
        file:close()

        local ok, users = pcall(json.decode, data)
        if not ok then
            ngx.log(ngx.ERR, "Erreur: Format JSON invalide")
            return redirect_to_404()  -- Redirection si le JSON est incorrect
        end

        -- Extraire user et pass depuis l'URL
        local user = ngx.var.arg_user
        local pass = ngx.var.arg_pass

        -- Ajouter des logs pour les identifiants
        ngx.log(ngx.INFO, "User: " .. tostring(user) .. ", Pass: " .. tostring(pass))

        -- Fonction de vérification des identifiants
        local function check_credentials(user, pass)
            for _, u in ipairs(users.users) do
                if u.user == user and u.pass == pass then
                    return true
                end
            end
            return false
        end

        -- Vérifier les identifiants
        if not check_credentials(user, pass) then
            ngx.log(ngx.ERR, "Accès refusé : Identifiants incorrects")
            return redirect_to_404()
        end

        -- Générer un token unique
        local token = ngx.encode_base64(tostring(ngx.now()))

        -- Extraire l'ID du stream depuis l'URL
        local id_stream = ngx.var.uri:match("/live/[^/]+/[^/]+/(.+)")
        if not id_stream then
            ngx.log(ngx.ERR, "Erreur: ID du stream manquant")
            return redirect_to_404()
        end

        -- Ajouter un log pour l'ID du stream
        ngx.log(ngx.INFO, "ID du stream : " .. tostring(id_stream))

        -- Effectuer une requête vers /streaming pour récupérer {IP}|{nom}
        local httpc = http.new()
        local res, err = httpc:request_uri("http://localhost:9090/streaming", {
            method = "GET",
            query = { name = id_stream },
        })

        if not res or res.status ~= 200 then
            ngx.log(ngx.ERR, "Erreur: Impossible de récupérer les informations du stream, statut : " .. tostring(res and res.status or "nil"))
            return redirect_to_404()
        end

        -- Analyser la réponse sous la forme {adresse IP}|{nom}
        local ip, channel_name = res.body:match("([^|]+)|([^|]+)")
        if not ip or not channel_name then
            ngx.log(ngx.ERR, "Erreur: Format de réponse invalide")
            return redirect_to_404()
        end

        -- Construire l'URL de redirection
        local target_url = "http://" .. ip .. "/live/" .. channel_name .. "?token=" .. token
        ngx.log(ngx.INFO, "Redirection vers : " .. target_url)

        -- Effectuer la redirection vers le bon serveur
        ngx.redirect(target_url)
        }
    }

    location /clients.json {
        alias /var/www/html/clients.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /monitoring.json {
        alias /var/www/html/monitoring.json;
        default_type application/json;
        add_header Access-Control-Allow-Origin *;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /update {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /last-modified {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-xtream {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-info {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-nginx-client-config {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-bandwidth {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /save-kickoff {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /cancel-clients {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        add_header Pragma "no-cache";
        expires off;
    }

    location /streaming {
        content_by_lua_block {
            local cjson = require "cjson"

            -- Ouvrir et lire le fichier streaming_run.json
            local file = io.open("/var/www/html/streaming_run.json", "r")
            if not file then
                ngx.say("999")  -- Retourner 999 si le fichier ne peut pas être lu
                return
            end

            local content = file:read("*all")
            file:close()
            local data = cjson.decode(content)

            -- Récupérer la valeur du paramètre `name` depuis l'URL
            local channel_name = ngx.var.arg_name
            if not channel_name then
                ngx.say("333")  -- Retourner 333 si le paramètre 'name' est manquant
                return
            end

            -- Transformer channel_name en pattern Lua pour ignorer le chiffre central
            local pattern = "^" .. channel_name:gsub("_(%d+)_", "_%%d+_") .. "$"

            -- Chercher le serveur et le channel correspondant
            local best_server = nil
            local matched_channel = nil
            local min_nbc = math.huge  -- Initialisation à l'infini

            for _, server in ipairs(data) do
                if server.channel:match(pattern) then
                    if server.nbc < min_nbc then
                        min_nbc = server.nbc
                        best_server = server.serveur
                        matched_channel = server.channel  -- Stocker le channel correspondant
                    elseif server.nbc == min_nbc then
                        -- En cas d'égalité, choisir un serveur aléatoirement
                        if math.random() < 0.5 then
                            best_server = server.serveur
                            matched_channel = server.channel
                        end
                    end
                end
            end

            -- Retourner la réponse appropriée
            if best_server and matched_channel then
                ngx.say(best_server .. "|" .. matched_channel)
            else
                ngx.say("666")  -- Retourner 666 si aucun serveur n'est trouvé
            end
        }
    }


}
