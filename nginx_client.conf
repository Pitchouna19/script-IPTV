worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    lua_shared_dict token_store 10m;
    lua_shared_dict user_token_store 10m;
    lua_shared_dict global_vars 1m;  # Déclarer correctement le dictionnaire partagé pour l'IP publique

    init_worker_by_lua_block {
        local handle = io.popen("curl -s ifconfig.me")
        local public_ip = handle:read("*a"):match("^%s*(.-)%s*$")  -- Supprimer les espaces autour
        handle:close()
        
        -- Stocker dans global_vars (lua_shared_dict) pour un usage global
        ngx.shared.global_vars:set("public_ip", public_ip)
        ngx.log(ngx.NOTICE, "IP publique initialisée : " .. public_ip)
    }

    server {
        listen 9090;
        server_name localhost;

        access_log /var/log/nginx/access.log;  # Chemin pour les logs d'accès
        error_log /var/log/nginx/error.log;    # Chemin pour les logs d'erreur

        location / {
            root   html;
            index  index.html index.htm;
        }

        # Point d'entrée du client
        location /live/ {
            content_by_lua_block {
                local token_store = ngx.shared.token_store
                local user_token_store = ngx.shared.user_token_store
                local public_ip = ngx.shared.global_vars:get("public_ip") or "inconnue"

                local token = ngx.var.arg_token
                local user = ngx.var.arg_user
                local ip = ngx.var.arg_ip
                

                if not token then
                    ngx.status = 401
                    ngx.say("Accès refusé : Token manquant")
                    return
                end

                if not user then
                    ngx.status = 401
                    ngx.say("Accès refusé : Utilisateur manquant")
                    return
                end

                local exists = token_store:get(token)
                if exists then
                    ngx.status = 403
                    ngx.say("Accès refusé : Token déjà utilisé")
                    return
                end

                local old_token = user_token_store:get(user)
                if old_token then
                    token_store:delete(old_token)
                    ngx.log(ngx.NOTICE, "Ancien token invalidé pour l'utilisateur: " .. user)
                end

                user_token_store:set(user, token, 60)  -- Expiration : 60s
                token_store:set(token, true, 60)       -- Expiration : 60s

                local stream_name = ngx.var.uri:match("^/live/(.+)$")
                
                if stream_name then
                    -- Log la redirection
                    ngx.log(ngx.NOTICE, "Redirection interne pour: " .. stream_name)
                    -- Ajout d'un en-tête personnalisé pour transmettre le nom du flux
                    ngx.req.set_header("X-Stream-Name", stream_name)
                    -- Ajouter un en-tête personnalisé avec l'IP du client
                    ngx.req.set_header("X-Client-IP", public_ip)
                    
                    -- Redirige vers /internal_stream sans changer l'URI
                    return ngx.exec("/internal_stream/")
                else
                    ngx.status = 404
                    ngx.say("Stream non trouvé")
                    return
                end
            }
        }

        # Route interne vers le serveur SRS
        location /internal_stream/ {
            internal;  # Empêcher l’accès direct

            # Utilisation de l'en-tête personnalisé pour reformer l'URL
            set $stream_name $http_x_stream_name;

            # Reforme l'URL avec /live/stream_name.flv
            proxy_pass http://$http_x_client_ip:8080/live/$stream_name.flv;

            # Paramètres proxy pour réduire le buffering
            proxy_buffering off;  # Désactive le buffering du proxy
            proxy_request_buffering off;  # Désactive le buffering des requêtes du client
            proxy_cache_bypass $http_upgrade;  # Bypass du cache pour les flux en direct
            proxy_no_cache $http_upgrade;  # Ne pas mettre en cache les réponses
        
            # Timeout pour maintenir la connexion active
            proxy_connect_timeout 1s;  # Timeout de connexion rapide
            proxy_send_timeout 60s;  # Timeout pour l’envoi des paquets vers le backend
            proxy_read_timeout 60s;  # Timeout pour la lecture du backend
        
            # Tampons plus petits pour éviter des retards d’accumulation de données
            proxy_buffers 8 1k;  # Nombre et taille des tampons utilisés
            proxy_buffer_size 1k;  # Taille du tampon de réponse initial
        
            # Passer les en-têtes nécessaires
            
            # Transmettre l'IP du client au serveur en aval via l'en-tête Host
            proxy_set_header Host $http_x_client_ip;

            #
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root html;
        }
    }
}
